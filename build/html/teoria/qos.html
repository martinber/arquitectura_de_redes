

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="es" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="es" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>QOS &mdash; documentación de Arquitectura de Redes - </title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script type="text/javascript" src="../_static/jquery.js"></script>
        <script type="text/javascript" src="../_static/underscore.js"></script>
        <script type="text/javascript" src="../_static/doctools.js"></script>
        <script type="text/javascript" src="../_static/language_data.js"></script>
        <script type="text/javascript" src="../_static/translations.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Índice" href="../genindex.html" />
    <link rel="search" title="Búsqueda" href="../search.html" />
    <link rel="next" title="Acceso remoto" href="acceso_remoto.html" />
    <link rel="prev" title="TLS" href="tls.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> Arquitectura de Redes
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">Teoría</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="index.html#principal">Principal</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#wan-y-ruteo">WAN y ruteo</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="index.html#capa-aplicacion-y-otros">Capa aplicación y otros</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="6to4.html">6to4</a></li>
<li class="toctree-l3"><a class="reference internal" href="dns.html">DNS</a></li>
<li class="toctree-l3"><a class="reference internal" href="mail.html">Mail</a></li>
<li class="toctree-l3"><a class="reference internal" href="ftp.html">FTP</a></li>
<li class="toctree-l3"><a class="reference internal" href="http.html">HTTP</a></li>
<li class="toctree-l3"><a class="reference internal" href="p2p.html">P2P</a></li>
<li class="toctree-l3"><a class="reference internal" href="multimedia.html">Multimedia</a></li>
<li class="toctree-l3"><a class="reference internal" href="voip.html">VOIP</a></li>
<li class="toctree-l3"><a class="reference internal" href="gestion.html">Gestión de redes</a></li>
<li class="toctree-l3"><a class="reference internal" href="seguridad.html">Seguridad</a></li>
<li class="toctree-l3"><a class="reference internal" href="tls.html">TLS</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">QOS</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#arquitectura">Arquitectura</a></li>
<li class="toctree-l4"><a class="reference internal" href="#intserv">IntServ</a></li>
<li class="toctree-l4"><a class="reference internal" href="#sla">SLA</a></li>
<li class="toctree-l4"><a class="reference internal" href="#netflow">Netflow</a></li>
<li class="toctree-l4"><a class="reference internal" href="#control-de-trafico-en-linux">Control de tráfico en Linux</a></li>
<li class="toctree-l4"><a class="reference internal" href="#colas">Colas</a></li>
<li class="toctree-l4"><a class="reference internal" href="#referencias">Referencias</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="acceso_remoto.html">Acceso remoto</a></li>
<li class="toctree-l3"><a class="reference internal" href="programacion.html">Programación</a></li>
<li class="toctree-l3"><a class="reference internal" href="gns3.html">GNS3</a></li>
<li class="toctree-l3"><a class="reference internal" href="wireshark.html">Wireshark</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../practica/index.html">Práctica</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Arquitectura de Redes</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">Teoría</a> &raquo;</li>
        
      <li>QOS</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/teoria/qos.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="qos">
<h1>QOS<a class="headerlink" href="#qos" title="Enlazar permanentemente con este título">¶</a></h1>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Por hacer</p>
<p>Hacer. Ver <a class="reference external" href="http://web.opalsoft.net/qos/default.php?p=ds-21">http://web.opalsoft.net/qos/default.php?p=ds-21</a></p>
</div>
<p>QoS hace referencia al uso de tecnologías que permiten administrar datos y
paquetes para reducir la pérdida de paquetes, latencia y jitter en la red, como
así también para manejar ancho de banda.
Debido a esto es necesario que los routers deben priorizar tráficos sobre otros,
aplicando mecanismos de control del ancho de banda que limiten la tasa de datos
ya sea mediante direcciones IP, protocolos, puertos, entre otros.</p>
<p>Existen dos tipos de aplicaciones, que se diferencian según sus requisitos:</p>
<ul class="simple">
<li><p>Elásticas: son flexibles en requerimientos de ancho de banda y se adaptan a</p></li>
</ul>
<p>a las condiciones de la red, por ejemplo TCP, mails, aplicaciones WEB,
transferencia de archivos.</p>
<ul class="simple">
<li><p>Inelásticas: no son tan flexibles, ya que necesitan de que se cumplan ciertos</p></li>
</ul>
<p>parámetros mínimos de ancho de banda para que puedan funcionar correctamente,
por ejemplo VOIP, videoconferencia.</p>
<p>Se define a un fujo como una secuencia de datagramas o segmentos que son el
resultado de una acción del usuario y requiere la misma QoS. Es unidireccional
y la entidad mínima a la cual un router puede aplicarle QoS. Se identifica por
cinco parámetros puerto e IP de origen y destino y el protocolo (TCP o UDP).</p>
<ul class="simple">
<li><p>QoS (Quality of Service): se refiere a la priorización y clasificación del
tráfico en general, puede ser mediante técnicas de policing, shaping, entre otras.</p></li>
<li><p>CoS (Class of Service): es un campo en el header de Ethernet, mas precisamente
en la parte de VLAN, en donde se puede diferencia los servicios para luego
darles prioridad</p></li>
<li><p>ToS (Type of Service): segundo byte en el header de IP donde se puede
especificar algun tipo de prioridad. En la actualidad se utiliza DSCP
(Differenciated Services Code Point) que son 5 bits de ese byte reservado.</p></li>
</ul>
<p>IP QOS peermite calidad de servicio extremo a extremo, de capa 2 como VLAN no</p>
<p>La cola es punteros a memoria. Un buffer es la memoria.</p>
<ul class="simple">
<li><p>Es lo mismo QoS en IPv4 que en IPv6 basicamente, cambian un poco los headers
nomas</p></li>
<li><p>Solamente se puede controlar lo que sale para el tema de prioridades. El
marcado es a la entrada.</p></li>
</ul>
<div class="section" id="arquitectura">
<h2>Arquitectura<a class="headerlink" href="#arquitectura" title="Enlazar permanentemente con este título">¶</a></h2>
<ul class="simple">
<li><p>Grandes grupos: mecansimos de control de datos o control de caminos.</p></li>
<li><p>Clasificación:</p>
<ul>
<li><p>Por flujo: Secuencia de datagramas (IP origen y destino, puerto origen y
destino, protocolo). Cada conexion TCP tiene tiene 2 flujos.</p></li>
<li><p>Stream.</p></li>
<li><p>Clase trafico.</p></li>
<li><p>Campo de IP.</p></li>
<li><p>MPLS.</p></li>
<li><p>Capa 2.</p></li>
<li><p>Inspección profunda.</p></li>
</ul>
</li>
<li><p>Policing: Su función es asegurar que un tráfico no supere una tasa máxima determinada,
controlando el ancho de banda y descartando aquellos paquetes que hagan que se
supere esta tasa.</p></li>
<li><p>Shaping: También asegura que un tráfico no supere una tasa determinada pero a diferencia
del policer, en vez de descartar paquetes que hagan exceder la tasa, los retrasa
suavizando la transferencia.</p></li>
<li><p>Marking: Es el marcado de paquetes mediante una etiqueta que le permite a los
routers, mediante un acuerdo previo, para darle un tratamiento determinado. No
hay reserva de recursos por flujo, ni protocolo de señalización, ni información
de estado en los routers.. Para marcar usamos la tabla mangle de iptables.</p></li>
<li><p>Token Bucket
Mecanismo para limitar la tasa media de transferencia, permitiendo ráfagas hasta
un tamaño máximo. Se puede dividir en:
- CIR: Commited Information Rate - Tasa de Caudal Comprometido
- CBS: Commited Burst Size – Tamaño de Ráfaga Comprometido
- T: Time Interval</p></li>
</ul>
<div class="admonition-todo admonition" id="id2">
<p class="admonition-title">Por hacer</p>
<p>Random Early Detection, RED, WRED.</p>
</div>
<div class="section" id="tos">
<h3>TOS<a class="headerlink" href="#tos" title="Enlazar permanentemente con este título">¶</a></h3>
<p>En IPv4:
- Type of Service (8 bits): Para hacer calidad de servicios.</p>
<blockquote>
<div><ul class="simple">
<li><p>Precedencia (3 bits): prioridad, con ocho niveles en total. Mayor tiene más</p></li>
</ul>
<p>prioridad
- D (1 bit): delay (retardo mínimo)
- T (1 bit): throughput (máximo rendimiento)
- R (1 bit): reliability (máxima fiabilidad)
- C (1 bit): cost (mínimo costo)
- X (1 bit): bit reservado</p>
</div></blockquote>
</div>
<div class="section" id="dscp">
<h3>DSCP<a class="headerlink" href="#dscp" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Luego de ToS se redefinió el byte utilizado en ToS, dando origen a DSCP, tanto en IPV4
como en IPV6. Este nuevo campo consiste:</p>
<ul class="simple">
<li><p>Differenciated Service Code Point o DSCP (6 bits): indica el tratamiento</p></li>
</ul>
<p>que debe recibir el paquete</p>
<ul class="simple">
<li><p>Currently unused (2 bits): actualmente se lo utiliza para control de congestion</p></li>
</ul>
<p>Marca los paquetes con una etiqueta y acuerda con los routers un tratamiento
específico, sin reserva de recursos por flujo, ni protocolo de señalización, ni
información de estado de routers. Las garantías de calidad de servicio no son
tan estrictas como en IntServ, pero suelen ser suficientes.</p>
<p>Se denomina al comportamiento de reenvío asignado PHB (per hop behaviour). PHB
determina la procedencia del paquete marcado en relación con otro tráfico del
sistema con DiffServ, y luego decide si el sistema reenvía o descarta dicho
paquete. Cada router con DiffServ aplica el mismo PHB al paquete.
Cada PHB consta de dos componentes:
- Una definición formal de comportamiento requerido
- Un sistema de marca recomendado para clasificar los paquetes</p>
<p>De los 6 bits utilizados en este campo para clasificar tráfico, se encuentran
distintas clases:</p>
<ul class="simple">
<li><p>111xxx: control de la red, precedencia 7</p></li>
<li><p>110xxx: control de la red, precedencia 6</p></li>
<li><p>101xxx: Expedited Forwarding, precedencia 5</p></li>
<li><p>100xxx: Assured Forwarding clase 4, precedencia 4</p></li>
<li><p>011xxx: Assured Forwarding clase 3, precedencia 3</p></li>
<li><p>010xxx: Assured Forwarding clase 2, precedencia 2</p></li>
<li><p>001xxx: Assured Forwarding clase 1, precedencia 1</p></li>
<li><p>000xxx: Best Effort, precedencia 0</p></li>
</ul>
<p>Expedited Forwarding garantiza caudal, tasa de pérdida, jitter y retardo,
equivale a una línea dedicada. Es como un acuerdo de SLA
Assured Forwarding asegura un trato preferente pero sin dar garantías. Tiene 4
clases y en cada una hay tres probabilidades de descarte (alta, media y baja).
Best Effort no tiene garantías.</p>
<ul class="simple">
<li><p>PHB: Per Hop Behavior. Lo que hace cada router. Los routers en conjunto son un
dominio DiffServ.</p></li>
</ul>
</div>
</div>
<div class="section" id="intserv">
<h2>IntServ<a class="headerlink" href="#intserv" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Se basa en la reserva previa de recursos en todo el trayecto. Para esto utiliza
el protocolo RSVP (Resource reSerVation Protocol), que garantiza la QoS
solicitada. De no haber recursos disponibles, se rechaza la petición, ejerciendo
control de admisión o CAC (Connection Admission Control)</p>
<p>IntServ se desarrolló antes que DiffServ, pero lo mas utilizado es este último.
Esto se debe a la capacidad de escalabilidad que tiene a diferencia de IntServ
que tiene un gran consumo de recursos.</p>
</div>
<div class="section" id="sla">
<h2>SLA<a class="headerlink" href="#sla" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Service Level Agreement.</p>
<ul class="simple">
<li><p>Contrato entre usuario y operador de red.</p></li>
<li><p>ITU-T E.860 define el marco? una estructura generica.</p></li>
<li><p>Parametros posibles:</p>
<ul>
<li><p>Disponibilidad. por porcentaje, cuantas hhoras por dia, cuantas horas
seguidas, etc.</p></li>
<li><p>Ancho de banda.</p></li>
<li><p>Perdida de paquetes, por porcentaje. 1 de cada 100 vs 10 de cada 1000.</p></li>
<li><p>RTT.</p></li>
<li><p>Jitter.</p></li>
<li><p>Etc.</p></li>
</ul>
</li>
<li><p>La IPTF estableció la IPPM que hace estandares de medicion.</p></li>
</ul>
</div>
<div class="section" id="netflow">
<h2>Netflow<a class="headerlink" href="#netflow" title="Enlazar permanentemente con este título">¶</a></h2>
<ul class="simple">
<li><p>Netflow</p></li>
<li><p>ELK: Elastic search, ???, Kibana?</p></li>
</ul>
</div>
<div class="section" id="control-de-trafico-en-linux">
<h2>Control de tráfico en Linux<a class="headerlink" href="#control-de-trafico-en-linux" title="Enlazar permanentemente con este título">¶</a></h2>
<p>Desde <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">tc</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Qdiscs

  qdisc is short for &#39;queueing discipline&#39; and it is elementary to
  understanding traffic control. Whenever the kernel needs to send a packet to
  an interface, it is enqueued to the qdisc configured for that interface.
  Immediately afterwards, the kernel tries to get as many packets as possible
  from the qdisc, for giving them to the network adaptor driver.

  A simple QDISC is the &#39;pfifo&#39; one, which does no processing at all and is a
  pure First In, First Out queue. It does however store traffic when the
  network interface can&#39;t handle it momentarily.

Classes

  Some qdiscs can contain classes, which contain further qdiscs - traffic may
  then be enqueued in any of the inner qdiscs, which are within the classes.
  When the kernel tries to dequeue a packet from such a classful qdisc it can
  come from any of the classes. A qdisc may for example prioritize certain
  kinds of traffic by trying to dequeue from certain classes before others.

Filters

  A filter is used by a classful qdisc to determine in which class a packet
  will be enqueued. Whenever traffic arrives at a class with subclasses, it
  needs to be classified. Various methods may be employed to do so, one of
  these are the filters. All filters attached to the class are called, until
  one of them returns with a verdict. If no verdict was made, other criteria
  may be available. This differs per qdisc.

  It is important to notice that filters reside within qdiscs - they are not
  masters of what happens.
</pre></div>
</div>
<div class="section" id="qdisc">
<h3>qdisc<a class="headerlink" href="#qdisc" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Sacado de <a class="reference external" href="https://www.tldp.org/HOWTO/Traffic-Control-HOWTO">acá</a>:</p>
<blockquote>
<div><p>Simply put, a qdisc is a scheduler (Section 3.2). Other qdiscs available under
Linux will rearrange the packets entering the scheduler’s queue in accordance
with that scheduler’s rules.</p>
<p>The qdisc is the major building block on which all of Linux traffic control is
built, and is also called a queuing discipline.</p>
<p>The classful qdiscs can contain classes, and provide a handle to which to attach
filters. There is no prohibition on using a classful qdisc without child
classes, although this will usually consume cycles and other system resources
for no benefit.</p>
<p>The classless qdiscs can contain no classes, nor is it possible to attach filter
to a classless qdisc. Because a classless qdisc contains no children of any
kind, there is no utility to classifying. This means that no filter can be
attached to a classless qdisc.</p>
<p>A source of terminology confusion is the usage of the terms root qdisc and
ingress qdisc. These are not really queuing disciplines, but rather locations
onto which traffic control structures can be attached for egress (outbound
traffic) and ingress (inbound traffic).</p>
<p>Each interface contains both. The primary and more common is the egress qdisc,
known as the root qdisc. It can contain any of the queuing disciplines (qdiscs)
with potential classes and class structures. The overwhelming majority of
documentation applies to the root qdisc and its children. Traffic transmitted on
an interface traverses the egress or root qdisc.</p>
<p>For traffic accepted on an interface, the ingress qdisc is traversed. With its
limited utility, it allows no child class to be created, and only exists as an
object onto which a filter can be attached. For practical purposes, the ingress
qdisc is merely a convenient object onto which to attach a policer to limit the
amount of traffic accepted on a network interface.</p>
<p>In short, you can do much more with an egress qdisc because it contains a real
qdisc and the full power of the traffic control system. An ingress qdisc can
only support a policer. The remainder of the documentation will concern itself
with traffic control structures attached to the root qdisc unless otherwise
specified</p>
</div></blockquote>
</div>
<div class="section" id="class">
<h3>class<a class="headerlink" href="#class" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Sacado de <a class="reference external" href="https://www.tldp.org/HOWTO/Traffic-Control-HOWTO">acá</a>:</p>
<blockquote>
<div><p>Classes only exist inside a classful qdisc (e.g., HTB and CBQ). Classes are
immensely flexible and can always contain either multiple children classes or a
single child qdisc. There is no prohibition against a class containing a
classful qdisc itself, which facilitates tremendously complex traffic control
scenarios.</p>
<p>Any class can also have an arbitrary number of filters attached to it, which
allows the selection of a child class or the use of a filter to reclassify or
drop traffic entering a particular class.</p>
<p>A leaf class is a terminal class in a qdisc. It contains a qdisc (default FIFO)
and will never contain a child class. Any class which contains a child class is
an inner class (or root class) and not a leaf class.</p>
</div></blockquote>
</div>
</div>
<div class="section" id="colas">
<h2>Colas<a class="headerlink" href="#colas" title="Enlazar permanentemente con este título">¶</a></h2>
<div class="section" id="cir">
<h3>CIR<a class="headerlink" href="#cir" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition-todo admonition" id="id4">
<p class="admonition-title">Por hacer</p>
<p>Es un buffer cicular? Supuestamente es policer?</p>
</div>
</div>
<div class="section" id="ebs">
<h3>EBS<a class="headerlink" href="#ebs" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition-todo admonition" id="id5">
<p class="admonition-title">Por hacer</p>
<p>No la encuentro?? Supuestamente es policer?</p>
</div>
</div>
<div class="section" id="t">
<h3>T<a class="headerlink" href="#t" title="Enlazar permanentemente con este título">¶</a></h3>
<div class="admonition-todo admonition" id="id6">
<p class="admonition-title">Por hacer</p>
<p>No la encuentro?? Supuestamente es policer?</p>
</div>
</div>
<div class="section" id="pfifo">
<h3>pfifo<a class="headerlink" href="#pfifo" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Classless.</p>
<p>FIFO significa que el primer paquete que entra es el primero en salir.</p>
<p>Ver <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">tc-pfifo</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>They are the simplest queues possible and therefore have no overhead. pfifo
constrains the queue size as measured in packets. bfifo does so as measured
in bytes.
</pre></div>
</div>
</div>
<div class="section" id="pfifo-fast">
<h3>pfifo_fast<a class="headerlink" href="#pfifo-fast" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Classless.</p>
<p>Es la cola por defecto en Linux y Mikrotik. Es classless pero contienen tres
colas en el caso que se quiera dar prioridades.</p>
<p>Ver <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">tc-pfifo_fast</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>pfifo_fast is the default qdisc of each interface.

The algorithm is very similar to that of the classful tc-prio(8) qdisc.
pfifo_fast is like three tc-pfifo(8) queues side by side, where packets can
be enqueued in any of the three bands based on their Type of Service bits or
assigned priority.

Not all three bands are dequeued simultaneously - as long as lower bands have
traffic, higher bands are never dequeued. This can be used to prioritize
interactive traffic or penalize &#39;lowest cost&#39; traffic.

Each band can be txqueuelen packets long, as configured with ifconfig(8) or
ip(8). Additional packets coming in are not enqueued but are instead dropped.

See tc-prio(8) for complete details on how TOS bits are translated into bands.
</pre></div>
</div>
</div>
<div class="section" id="cbs">
<h3>CBS<a class="headerlink" href="#cbs" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Classless.</p>
<p>De shaping.</p>
<p>Creo que nunca la usamos. Ver <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">tc-cbs</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The CBS (Credit Based Shaper) qdisc implements the shaping algorithm defined
by the IEEE 802.1Q-2014 Section 8.6.8.2, which applies a well defined rate
limiting method to the traffic.

This queueing discipline is intended to be used by TSN (Time Sensitive
Networking) applications, the CBS parameters are derived directly by what is
described by the Annex L of the IEEE 802.1Q-2014 Specification. The algorithm
and how it affects the latency are detailed there.

CBS is meant to be installed under another qdisc that maps packet flows to
traffic classes, one example is mqprio(8).
</pre></div>
</div>
</div>
<div class="section" id="tocken-bucket-filter">
<h3>Tocken Bucket Filter<a class="headerlink" href="#tocken-bucket-filter" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Classless.</p>
<p>Ver <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">tc-tbf</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The Token Bucket Filter is a classful queueing discipline available for
traffic control with the tc(8) command.

As the name implies, traffic is filtered based on the expenditure of tokens.
Tokens roughly correspond to bytes, with the additional constraint that each
packet consumes some tokens, no matter how small it is. This reflects the fact
that even a zero-sized packet occupies the link for some time.
</pre></div>
</div>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tc qdisc add dev eth0 root tbf rate 220kbit latency 50ms burst 1540
</pre></div>
</div>
</div>
<div class="section" id="sfq">
<h3>SFQ<a class="headerlink" href="#sfq" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Classless.</p>
<p>Como la FIFO con bandas.</p>
<p>Ver <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">tc-sfq</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Stochastic Fairness Queueing is a classless queueing discipline available for
traffic control with the tc(8) command.

SFQ does not shape traffic but only schedules the transmission of packets,
based on &#39;flows&#39;. The goal is to ensure fairness so that each flow is able to
send data in turn, thus preventing any single flow from drowning out the rest.

This may in fact have some effect in mitigating a Denial of Service attempt.
</pre></div>
</div>
<p>Ver el <a class="reference external" href="https://wiki.mikrotik.com/wiki/Manual:Queue#SFQ">manual de Mikrotik</a>:</p>
<blockquote>
<div><p>Stochastic Fairness Queuing (SFQ) is ensured by hashing and round-robin
algorithms. A traffic flow may be uniquely identified by a 4
options(src-address, dst-address, src-port and dst-port), so these parameters
are used by SFQ hashing algorithm to classify packets into one of 1024
possible sub-streams. Then round-robin algorithm will start to distribute
available bandwidth to all sub-streams, on each round giving sfq-allot bytes
of traffic. The whole SFQ queue can contain 128 packets and there are 1024
sub-streams available.</p>
<p>SFQ is called «Stochastic» because it does not really allocate a queue for
each flow, it has an algorithm which divides traffic over a limited number of
queues (1024) using a hashing algorithm.</p>
</div></blockquote>
<p>Nosotros ponemos que se reconfigure cada 10 segundos:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>tc qudisc add dev ent0 root sfq perturb 10
</pre></div>
</div>
</div>
<div class="section" id="pcq">
<h3>PCQ<a class="headerlink" href="#pcq" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Classless.</p>
<p>Similar a SFQ pero solo para Mikrotik creo.</p>
<p>Ver el <a class="reference external" href="https://wiki.mikrotik.com/wiki/Manual:Queue#PCQ">manual de Mikrotik</a>:</p>
<blockquote>
<div><p>Per Connection Queuing (PCQ) is a similar to SFQ, but it has additional features.</p>
<p>It is possible to choose flow identifiers (from dst-address | dst-port |
src-address | src-port). For example if you classify flows by src-address on
local interface (interface with your clients), each PCQ sub-stream will be one
particular client’s upload.</p>
<p>It is possible to assign speed limitation to sub-streams with pcq-rate option.
If pcq-rate=0 sub-streams will divide available traffic equally.</p>
<p>PCQ was introduced to optimize massive QoS systems, where most of the queues are
exactly the same for different sub-streams. For example a sub-stream can be
download or upload for one particular client (IP) or connection to server.</p>
<p>PCQ algorithm is very simple - at first it uses selected classifiers to
distinguish one sub-stream from another, then applies individual FIFO queue size
and limitation on every sub-stream, then groups all sub-streams together and
applies global queue size and limitation.</p>
</div></blockquote>
</div>
<div class="section" id="prio">
<h3>PRIO<a class="headerlink" href="#prio" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Classful.</p>
<p>Es como pfifo_fast que ordena paquetes en solamente 3 bandas.</p>
<p>Hay que tener cuidado de que la suma de las hijas no sea mayor a la de arriba,
porque en tal caso deja de andar y es como que no limita nada, pasa todo de
largo.</p>
<p>Ver <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">tc-prio</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>The PRIO qdisc is a simple classful queueing discipline that contains an
arbitrary number of classes of differing priority. The classes are dequeued in
numerical descending order of priority. PRIO is a scheduler and never delays
packets - it is a work-conserving qdisc, though the qdiscs contained in the
classes may not be.

Very useful for lowering latency when there is no need for slowing down traffic.

On creation with &#39;tc qdisc add&#39;, a fixed number of bands is created. Each band
is a class, although is not possible to add classes with &#39;tc qdisc add&#39;, the
number of bands to be created must instead be specified on the command line
attaching PRIO to its root.

When dequeueing, band 0 is tried first and only if it did not deliver a packet
does PRIO try band 1, and so onwards. Maximum reliability packets should
therefore go to band 0, minimum delay to band 1 and the rest to band 2.

As the PRIO qdisc itself will have minor number 0, band 0 is actually major:1,
band 1 is major:2, etc. For major, substitute the major number assigned to the
qdisc on &#39;tc qdisc add&#39; with the handle parameter.
</pre></div>
</div>
</div>
<div class="section" id="cbq">
<h3>CBQ<a class="headerlink" href="#cbq" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Classful.</p>
<p>Permite prestar trafico a otra rama cuando no lo usa, creo que es el único que
deja hacer eso de las que vemos, pero hay otras variaciones. Muy dificil de
configurar, hay que hacer cuentas.</p>
<p>Es como la prio pero hace un round robin con pesos que se van calculando
dinamicamene que se yo.</p>
<p>Ver <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">tc-cbq</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>Class Based Queueing is a classful qdisc that implements a rich linksharing
hierarchy of classes. It contains shaping elements as well as prioritizing
capabilities. Shaping is performed using link idle time calculations based on
the timing of dequeue events and underlying link bandwidth.
</pre></div>
</div>
</div>
<div class="section" id="htb">
<h3>HTB<a class="headerlink" href="#htb" title="Enlazar permanentemente con este título">¶</a></h3>
<p>Classful.</p>
<p>Token Bucket Filter con prioridades.</p>
<p>Ver <code class="docutils literal notranslate"><span class="pre">man</span> <span class="pre">tc-htb</span></code>:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>HTB is meant as a more understandable and intuitive replacement for the CBQ
qdisc in Linux. Both CBQ and HTB help you to control the use of the outbound
bandwidth on a given link.

Both allow you to use one physical link to simulate several slower links and to
send different kinds of traffic on different simulated links. In both cases, you
have to specify how to divide the physical link into simulated links and how to
decide which simulated link to use for a given packet to be sent.

Unlike CBQ, HTB shapes traffic based on the Token Bucket Filter algorithm which
does not depend on interface characteristics and so does not need to know the
underlying bandwidth of
the outgoing interface.
</pre></div>
</div>
</div>
</div>
<div class="section" id="referencias">
<h2>Referencias<a class="headerlink" href="#referencias" title="Enlazar permanentemente con este título">¶</a></h2>
<ul class="simple">
<li><p><a class="reference external" href="https://www.tldp.org/HOWTO/Traffic-Control-HOWTO/components.html#c-qdisc">https://www.tldp.org/HOWTO/Traffic-Control-HOWTO/components.html#c-qdisc</a></p></li>
</ul>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="acceso_remoto.html" class="btn btn-neutral float-right" title="Acceso remoto" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="tls.html" class="btn btn-neutral float-left" title="TLS" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018-2019, Martín Bernardi, Remedi Augusto, Rittano Ignacio

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>